'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

require('mochawait');

var _should = require('should');

var _should2 = _interopRequireDefault(_should);

var _libAsyncbox = require('../lib/asyncbox');

require('source-map-support').install();

/* global describe:true, it:true */
var regIt = it;

describe('sleep', function () {
  it('should work like setTimeout', function callee$1$0() {
    var now;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          now = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(20));

        case 3:
          (Date.now() - now).should.be.above(19);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});

describe('retry', function () {
  var okFnCalls = 0;
  var okFn = function okFn(val1, val2) {
    return _regeneratorRuntime.async(function okFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          okFnCalls++;
          return context$2$0.abrupt('return', val1 * val2);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badFnCalls = 0;
  var badFn = function badFn() {
    return _regeneratorRuntime.async(function badFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          badFnCalls++;
          throw new Error('bad');

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var eventuallyOkFnCalls = 0;
  var eventuallyOkFn = function eventuallyOkFn(times) {
    return _regeneratorRuntime.async(function eventuallyOkFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          eventuallyOkFnCalls++;

          if (!(eventuallyOkFnCalls < times)) {
            context$2$0.next = 5;
            break;
          }

          throw new Error('not ok yet');

        case 5:
          return context$2$0.abrupt('return', times * times);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var eventuallyOkNoSleepFn = function eventuallyOkNoSleepFn(times) {
    return _regeneratorRuntime.async(function eventuallyOkNoSleepFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          eventuallyOkFnCalls++;

          if (!(eventuallyOkFnCalls < times)) {
            context$2$0.next = 3;
            break;
          }

          throw new Error('not ok yet');

        case 3:
          return context$2$0.abrupt('return', times * times);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  it('should return the result of a passing function', function callee$1$0() {
    var start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, okFn, 5, 4));

        case 3:
          res = context$2$0.sent;

          res.should.equal(20);
          (Date.now() - start).should.be.above(14);
          okFnCalls.should.equal(1);

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should retry a failing function and eventually throw the same err', function callee$1$0() {
    var err, start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = null;
          start = Date.now();
          context$2$0.prev = 2;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, badFn));

        case 5:
          context$2$0.next = 10;
          break;

        case 7:
          context$2$0.prev = 7;
          context$2$0.t0 = context$2$0['catch'](2);

          err = context$2$0.t0;

        case 10:
          _should2['default'].exist(err);
          err.message.should.equal('bad');
          badFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(44);

        case 14:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[2, 7]]);
  });
  it('should return the correct value with a function that eventually passes', function callee$1$0() {
    var err, start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = null;
          start = Date.now();
          context$2$0.prev = 2;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, eventuallyOkFn, 4));

        case 5:
          context$2$0.next = 10;
          break;

        case 7:
          context$2$0.prev = 7;
          context$2$0.t0 = context$2$0['catch'](2);

          err = context$2$0.t0;

        case 10:
          _should2['default'].exist(err);
          err.message.should.equal('not ok yet');
          eventuallyOkFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(35);

          // rerun with ok number of calls
          start = Date.now();
          eventuallyOkFnCalls = 0;
          context$2$0.next = 18;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, eventuallyOkFn, 3));

        case 18:
          res = context$2$0.sent;

          eventuallyOkFnCalls.should.equal(3);
          res.should.equal(9);
          (Date.now() - start).should.be.above(35);

        case 22:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[2, 7]]);
  });
  it('in sleep mode, should return the correct value with a function that eventually passes', function callee$1$0() {
    var err, start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          eventuallyOkFnCalls = 0;
          err = null;
          start = Date.now();
          context$2$0.prev = 3;
          context$2$0.next = 6;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retryInterval)(3, 15, eventuallyOkNoSleepFn, 4));

        case 6:
          context$2$0.next = 11;
          break;

        case 8:
          context$2$0.prev = 8;
          context$2$0.t0 = context$2$0['catch'](3);

          err = context$2$0.t0;

        case 11:
          _should2['default'].exist(err);
          err.message.should.equal('not ok yet');
          eventuallyOkFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(30);

          // rerun with ok number of calls
          start = Date.now();
          eventuallyOkFnCalls = 0;
          context$2$0.next = 19;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retryInterval)(3, 15, eventuallyOkNoSleepFn, 3));

        case 19:
          res = context$2$0.sent;

          eventuallyOkFnCalls.should.equal(3);
          res.should.equal(9);
          (Date.now() - start).should.be.above(30);

        case 23:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[3, 8]]);
  });
});

describe('nodeifyAll', function () {
  var asyncFn = function asyncFn(val) {
    return _regeneratorRuntime.async(function asyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          return context$2$0.abrupt('return', val);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var asyncFn2 = function asyncFn2(val) {
    return _regeneratorRuntime.async(function asyncFn2$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          return context$2$0.abrupt('return', [val, val + val]);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badAsyncFn = function badAsyncFn() {
    return _regeneratorRuntime.async(function badAsyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          throw new Error('boo');

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var cbMap = (0, _libAsyncbox.nodeifyAll)({ asyncFn: asyncFn, asyncFn2: asyncFn2, badAsyncFn: badAsyncFn });
  regIt('should turn async functions into nodey things', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(asyncFn('foo'), function (err, val, val2) {
      _should2['default'].not.exist(err);
      _should2['default'].not.exist(val2);
      val.should.equal('foo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should turn async functions into nodey things via nodeifyAll', function (done) {
    var start = Date.now();
    cbMap.asyncFn('foo', function (err, val, val2) {
      _should2['default'].not.exist(err);
      _should2['default'].not.exist(val2);
      val.should.equal('foo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should turn async functions into nodey things with mult params', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(asyncFn2('foo'), function (err, val) {
      _should2['default'].not.exist(err);
      val.should.eql(['foo', 'foofoo']);
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should handle errors correctly', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(badAsyncFn('foo'), function (err, val) {
      _should2['default'].not.exist(val);
      err.message.should.equal('boo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
});

//describe('nodeifyAll', () => {
//let asyncFn = async (val) => {
//await sleep(15);
//return val;
//};
//let asyncFn2 = async (val) => {
//await sleep(15);
//return [val, val + val];
//};
//let badAsyncFn = async () => {
//await sleep(15);
//throw new Error('boo');
//};
//});

describe('parallel', function () {
  var asyncFn = function asyncFn(val) {
    return _regeneratorRuntime.async(function asyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(50));

        case 2:
          return context$2$0.abrupt('return', val);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badAsyncFn = function badAsyncFn() {
    return _regeneratorRuntime.async(function badAsyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(20));

        case 2:
          throw new Error('boo');

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  it('should perform tasks in parallel and return results', function callee$1$0() {
    var vals, promises, start, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v, res;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          vals = [1, 2, 3];
          promises = [];
          start = Date.now();
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 6;

          for (_iterator = _getIterator(vals); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            v = _step.value;

            promises.push(asyncFn(v));
          }
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](6);
          _didIteratorError = true;
          _iteratorError = context$2$0.t0;

        case 14:
          context$2$0.prev = 14;
          context$2$0.prev = 15;

          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }

        case 17:
          context$2$0.prev = 17;

          if (!_didIteratorError) {
            context$2$0.next = 20;
            break;
          }

          throw _iteratorError;

        case 20:
          return context$2$0.finish(17);

        case 21:
          return context$2$0.finish(14);

        case 22:
          context$2$0.next = 24;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)(promises));

        case 24:
          res = context$2$0.sent;

          (Date.now() - start).should.be.above(49);
          (Date.now() - start).should.be.below(59);
          res.sort().should.eql([1, 2, 3]);

        case 28:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[6, 10, 14, 22], [15,, 17, 21]]);
  });
  it('should error with first response', function callee$1$0() {
    var vals, promises, start, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, v, err, res;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          vals = [1, 2, 3];
          promises = [];
          start = Date.now();
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          context$2$0.prev = 6;

          for (_iterator2 = _getIterator(vals); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            v = _step2.value;

            promises.push(asyncFn(v));
          }
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](6);
          _didIteratorError2 = true;
          _iteratorError2 = context$2$0.t0;

        case 14:
          context$2$0.prev = 14;
          context$2$0.prev = 15;

          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }

        case 17:
          context$2$0.prev = 17;

          if (!_didIteratorError2) {
            context$2$0.next = 20;
            break;
          }

          throw _iteratorError2;

        case 20:
          return context$2$0.finish(17);

        case 21:
          return context$2$0.finish(14);

        case 22:
          promises.push(badAsyncFn());
          err = null;
          res = [];
          context$2$0.prev = 25;
          context$2$0.next = 28;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)(promises));

        case 28:
          res = context$2$0.sent;
          context$2$0.next = 34;
          break;

        case 31:
          context$2$0.prev = 31;
          context$2$0.t1 = context$2$0['catch'](25);

          err = context$2$0.t1;

        case 34:
          (Date.now() - start).should.be.above(19);
          (Date.now() - start).should.be.below(49);
          _should2['default'].exist(err);
          res.should.eql([]);

        case 38:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[6, 10, 14, 22], [15,, 17, 21], [25, 31]]);
  });
  it('should not allow parallelizing bad types of things', function callee$1$0() {
    var err;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = undefined;
          context$2$0.prev = 1;
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)([]));

        case 4:
          context$2$0.next = 9;
          break;

        case 6:
          context$2$0.prev = 6;
          context$2$0.t0 = context$2$0['catch'](1);

          err = context$2$0.t0;

        case 9:
          _should2['default'].exist(err);
          context$2$0.prev = 10;
          context$2$0.next = 13;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)('foo'));

        case 13:
          context$2$0.next = 18;
          break;

        case 15:
          context$2$0.prev = 15;
          context$2$0.t1 = context$2$0['catch'](10);

          err = context$2$0.t1;

        case 18:
          _should2['default'].exist(err);
          context$2$0.prev = 19;
          context$2$0.next = 22;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)([1]));

        case 22:
          context$2$0.next = 27;
          break;

        case 24:
          context$2$0.prev = 24;
          context$2$0.t2 = context$2$0['catch'](19);

          err = context$2$0.t2;

        case 27:
          _should2['default'].exist(err);

        case 28:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[1, 6], [10, 15], [19, 24]]);
  });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvYXN5bmNib3gtc3BlY3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztRQUlPLFdBQVc7O3NCQUNDLFFBQVE7Ozs7MkJBRUYsaUJBQWlCOztBQVAxQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7O0FBR3hDLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQzs7QUFNZixRQUFRLENBQUMsT0FBTyxFQUFFLFlBQU07QUFDdEIsSUFBRSxDQUFDLDZCQUE2QixFQUFFO1FBQzVCLEdBQUc7Ozs7QUFBSCxhQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTs7MkNBQ2QsaUJBTkQsS0FBSyxFQU1FLEVBQUUsQ0FBQzs7O0FBQ2YsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7R0FDeEMsQ0FBQyxDQUFDO0NBQ0osQ0FBQyxDQUFDOztBQUVILFFBQVEsQ0FBQyxPQUFPLEVBQUUsWUFBTTtBQUN0QixNQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDbEIsTUFBSSxJQUFJLEdBQUcsU0FBUCxJQUFJLENBQVUsSUFBSSxFQUFFLElBQUk7Ozs7OzJDQUNwQixpQkFkRCxLQUFLLEVBY0UsRUFBRSxDQUFDOzs7QUFDZixtQkFBUyxFQUFFLENBQUM7OENBQ0wsSUFBSSxHQUFHLElBQUk7Ozs7Ozs7R0FDbkIsQ0FBQztBQUNGLE1BQUksVUFBVSxHQUFHLENBQUMsQ0FBQztBQUNuQixNQUFJLEtBQUssR0FBRyxTQUFSLEtBQUs7Ozs7OzJDQUNELGlCQXBCRCxLQUFLLEVBb0JFLEVBQUUsQ0FBQzs7O0FBQ2Ysb0JBQVUsRUFBRSxDQUFDO2dCQUNQLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQzs7Ozs7OztHQUN2QixDQUFDO0FBQ0YsTUFBSSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7QUFDNUIsTUFB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QUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7OzJDQUVWLGlCQXJPSCxRQUFRLEVBcU9JLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFFbkIsYUFBRyxpQkFBSSxDQUFDOzs7QUFFViw4QkFBTyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Ozs7Ozs7R0FDbkIsQ0FBQyxDQUFDO0NBQ0osQ0FBQyxDQUFDIiwiZmlsZSI6InRlc3QvYXN5bmNib3gtc3BlY3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQnKS5pbnN0YWxsKCk7XG5cbi8qIGdsb2JhbCBkZXNjcmliZTp0cnVlLCBpdDp0cnVlICovXG5sZXQgcmVnSXQgPSBpdDtcbmltcG9ydCAnbW9jaGF3YWl0JztcbmltcG9ydCBzaG91bGQgZnJvbSAnc2hvdWxkJztcbmltcG9ydCB7IHNsZWVwLCByZXRyeSwgcmV0cnlJbnRlcnZhbCwgbm9kZWlmeSwgbm9kZWlmeUFsbCxcbiAgICAgICAgIHBhcmFsbGVsIH0gZnJvbSAnLi4vbGliL2FzeW5jYm94JztcblxuZGVzY3JpYmUoJ3NsZWVwJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHdvcmsgbGlrZSBzZXRUaW1lb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHNsZWVwKDIwKTtcbiAgICAoRGF0ZS5ub3coKSAtIG5vdykuc2hvdWxkLmJlLmFib3ZlKDE5KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ3JldHJ5JywgKCkgPT4ge1xuICBsZXQgb2tGbkNhbGxzID0gMDtcbiAgbGV0IG9rRm4gPSBhc3luYyAodmFsMSwgdmFsMikgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICBva0ZuQ2FsbHMrKztcbiAgICByZXR1cm4gdmFsMSAqIHZhbDI7XG4gIH07XG4gIGxldCBiYWRGbkNhbGxzID0gMDtcbiAgbGV0IGJhZEZuID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICBiYWRGbkNhbGxzKys7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICB9O1xuICBsZXQgZXZlbnR1YWxseU9rRm5DYWxscyA9IDA7XG4gIGxldCBldmVudHVhbGx5T2tGbiA9IGFzeW5jICh0aW1lcykgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzKys7XG4gICAgaWYgKGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPCB0aW1lcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IG9rIHlldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzICogdGltZXM7XG4gIH07XG4gIGxldCBldmVudHVhbGx5T2tOb1NsZWVwRm4gPSBhc3luYyAodGltZXMpID0+IHtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzKys7XG4gICAgaWYgKGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPCB0aW1lcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IG9rIHlldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzICogdGltZXM7XG4gIH07XG4gIGl0KCdzaG91bGQgcmV0dXJuIHRoZSByZXN1bHQgb2YgYSBwYXNzaW5nIGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IHJldHJ5KDMsIG9rRm4sIDUsIDQpO1xuICAgIHJlcy5zaG91bGQuZXF1YWwoMjApO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgxNCk7XG4gICAgb2tGbkNhbGxzLnNob3VsZC5lcXVhbCgxKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgcmV0cnkgYSBmYWlsaW5nIGZ1bmN0aW9uIGFuZCBldmVudHVhbGx5IHRocm93IHRoZSBzYW1lIGVycicsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZXRyeSgzLCBiYWRGbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKCdiYWQnKTtcbiAgICBiYWRGbkNhbGxzLnNob3VsZC5lcXVhbCgzKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoNDQpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgZXZlbnR1YWxseSBwYXNzZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmV0cnkoMywgZXZlbnR1YWxseU9rRm4sIDQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcXVhbCgnbm90IG9rIHlldCcpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgzNSk7XG5cbiAgICAvLyByZXJ1biB3aXRoIG9rIG51bWJlciBvZiBjYWxsc1xuICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzID0gMDtcbiAgICBsZXQgcmVzID0gYXdhaXQgcmV0cnkoMywgZXZlbnR1YWxseU9rRm4sIDMpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIHJlcy5zaG91bGQuZXF1YWwoOSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDM1KTtcbiAgfSk7XG4gIGl0KCdpbiBzbGVlcCBtb2RlLCBzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIHdpdGggYSBmdW5jdGlvbiB0aGF0IGV2ZW50dWFsbHkgcGFzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPSAwO1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMywgMTUsIGV2ZW50dWFsbHlPa05vU2xlZXBGbiwgNCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKCdub3Qgb2sgeWV0Jyk7XG4gICAgZXZlbnR1YWxseU9rRm5DYWxscy5zaG91bGQuZXF1YWwoMyk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDMwKTtcblxuICAgIC8vIHJlcnVuIHdpdGggb2sgbnVtYmVyIG9mIGNhbGxzXG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPSAwO1xuICAgIGxldCByZXMgPSBhd2FpdCByZXRyeUludGVydmFsKDMsIDE1LCBldmVudHVhbGx5T2tOb1NsZWVwRm4sIDMpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIHJlcy5zaG91bGQuZXF1YWwoOSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDMwKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ25vZGVpZnlBbGwnLCAoKSA9PiB7XG4gIGxldCBhc3luY0ZuID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBsZXQgYXN5bmNGbjIgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoMTUpO1xuICAgIHJldHVybiBbdmFsLCB2YWwgKyB2YWxdO1xuICB9O1xuICBsZXQgYmFkQXN5bmNGbiA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBzbGVlcCgxNSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib28nKTtcbiAgfTtcbiAgbGV0IGNiTWFwID0gbm9kZWlmeUFsbCh7YXN5bmNGbiwgYXN5bmNGbjIsIGJhZEFzeW5jRm59KTtcbiAgcmVnSXQoJ3Nob3VsZCB0dXJuIGFzeW5jIGZ1bmN0aW9ucyBpbnRvIG5vZGV5IHRoaW5ncycsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbm9kZWlmeShhc3luY0ZuKCdmb28nKSwgKGVyciwgdmFsLCB2YWwyKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KGVycik7XG4gICAgICBzaG91bGQubm90LmV4aXN0KHZhbDIpO1xuICAgICAgdmFsLnNob3VsZC5lcXVhbCgnZm9vJyk7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnSXQoJ3Nob3VsZCB0dXJuIGFzeW5jIGZ1bmN0aW9ucyBpbnRvIG5vZGV5IHRoaW5ncyB2aWEgbm9kZWlmeUFsbCcsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY2JNYXAuYXN5bmNGbignZm9vJywgKGVyciwgdmFsLCB2YWwyKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KGVycik7XG4gICAgICBzaG91bGQubm90LmV4aXN0KHZhbDIpO1xuICAgICAgdmFsLnNob3VsZC5lcXVhbCgnZm9vJyk7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnSXQoJ3Nob3VsZCB0dXJuIGFzeW5jIGZ1bmN0aW9ucyBpbnRvIG5vZGV5IHRoaW5ncyB3aXRoIG11bHQgcGFyYW1zJywgZG9uZSA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBub2RlaWZ5KGFzeW5jRm4yKCdmb28nKSwgKGVyciwgdmFsKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KGVycik7XG4gICAgICB2YWwuc2hvdWxkLmVxbChbJ2ZvbycsICdmb29mb28nXSk7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnSXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGNvcnJlY3RseScsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbm9kZWlmeShiYWRBc3luY0ZuKCdmb28nKSwgKGVyciwgdmFsKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KHZhbCk7XG4gICAgICBlcnIubWVzc2FnZS5zaG91bGQuZXF1YWwoJ2JvbycpO1xuICAgICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE0KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy9kZXNjcmliZSgnbm9kZWlmeUFsbCcsICgpID0+IHtcbiAgLy9sZXQgYXN5bmNGbiA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAvL2F3YWl0IHNsZWVwKDE1KTtcbiAgICAvL3JldHVybiB2YWw7XG4gIC8vfTtcbiAgLy9sZXQgYXN5bmNGbjIgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgLy9hd2FpdCBzbGVlcCgxNSk7XG4gICAgLy9yZXR1cm4gW3ZhbCwgdmFsICsgdmFsXTtcbiAgLy99O1xuICAvL2xldCBiYWRBc3luY0ZuID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vYXdhaXQgc2xlZXAoMTUpO1xuICAgIC8vdGhyb3cgbmV3IEVycm9yKCdib28nKTtcbiAgLy99O1xuLy99KTtcblxuZGVzY3JpYmUoJ3BhcmFsbGVsJywgKCkgPT4ge1xuICBsZXQgYXN5bmNGbiA9IGFzeW5jICh2YWwpID0+IHtcbiAgICBhd2FpdCBzbGVlcCg1MCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgbGV0IGJhZEFzeW5jRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoMjApO1xuICAgIHRocm93IG5ldyBFcnJvcihcImJvb1wiKTtcbiAgfTtcbiAgaXQoJ3Nob3VsZCBwZXJmb3JtIHRhc2tzIGluIHBhcmFsbGVsIGFuZCByZXR1cm4gcmVzdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgdmFscyA9IFsxLCAyLCAzXTtcbiAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IHYgb2YgdmFscykge1xuICAgICAgcHJvbWlzZXMucHVzaChhc3luY0ZuKHYpKTtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IHBhcmFsbGVsKHByb21pc2VzKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoNDkpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg1OSk7XG4gICAgcmVzLnNvcnQoKS5zaG91bGQuZXFsKFsxLCAyLCAzXSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGVycm9yIHdpdGggZmlyc3QgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHZhbHMgPSBbMSwgMiwgM107XG4gICAgbGV0IHByb21pc2VzID0gW107XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCB2IG9mIHZhbHMpIHtcbiAgICAgIHByb21pc2VzLnB1c2goYXN5bmNGbih2KSk7XG4gICAgfVxuICAgIHByb21pc2VzLnB1c2goYmFkQXN5bmNGbigpKTtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGF3YWl0IHBhcmFsbGVsKHByb21pc2VzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTkpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg0OSk7XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgcmVzLnNob3VsZC5lcWwoW10pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBub3QgYWxsb3cgcGFyYWxsZWxpemluZyBiYWQgdHlwZXMgb2YgdGhpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHBhcmFsbGVsKFtdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICBzaG91bGQuZXhpc3QoZXJyKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcGFyYWxsZWwoJ2ZvbycpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwYXJhbGxlbChbMV0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICB9KTtcbn0pO1xuIl19