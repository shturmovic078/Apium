'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _get = require('babel-runtime/helpers/get')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

_Object$defineProperty(exports, '__esModule', {
  value: true
});

var _child_process = require('child_process');

var _shellQuote = require('shell-quote');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _through = require('through');

var _through2 = _interopRequireDefault(_through);

var EventEmitter = _events2['default'].EventEmitter;

function exec(cmd) {
  var args = arguments[1] === undefined ? [] : arguments[1];
  var opts = arguments[2] === undefined ? {} : arguments[2];

  // get a quoted representation of the command for error strings
  var rep = _shellQuote.quote([cmd].concat(args));

  // extend default options; we're basically re-implementing exec's options
  // for use here with spawn under the hood
  opts = _Object$assign({
    timeout: null,
    encoding: 'utf8',
    killSignal: 'SIGTERM',
    cwd: undefined,
    env: process.env,
    ignoreOutput: false
  }, opts);

  // this is an async function, so return a promise
  return new _Promise(function (resolve, reject) {
    // spawn the child process with options; we don't currently expose any of
    // the other 'spawn' options through the API
    var proc = _child_process.spawn(cmd, args, { cwd: opts.cwd, env: opts.env });
    var stdout = '',
        stderr = '',
        timer = null;

    // if the process errors out, reject the promise
    proc.on('error', function (err) {
      reject(new Error('Command \'' + rep + '\' errored out: ' + err.stack));
    });

    // keep track of stdout/stderr if we haven't said not to
    if (!opts.ignoreOutput) {
      proc.stdout.on('data', function (data) {
        stdout += data;
      });
      proc.stderr.on('data', function (data) {
        stderr += data;
      });
    }

    // if the process ends, either resolve or reject the promise based on the
    // exit code of the process. either way, attach stdout, stderr, and code.
    // Also clean up the timer if it exists
    proc.on('close', function (code) {
      if (timer) {
        clearTimeout(timer);
      }
      stdout = stdout.toString(opts.encoding);
      stderr = stderr.toString(opts.encoding);
      if (code === 0) {
        resolve({ stdout: stdout, stderr: stderr, code: code });
      } else {
        var err = new Error('Command \'' + rep + '\' exited with code ' + code);
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: code });
        reject(err);
      }
    });

    // if we set a timeout on the child process, cut into the execution and
    // reject if the timeout is reached. Attach the stdout/stderr we currently
    // have in case it's helpful in debugging
    if (opts.timeout) {
      timer = setTimeout(function () {
        stdout = stdout.toString(opts.encoding);
        stderr = stderr.toString(opts.encoding);
        var err = new Error('Command \'' + rep + '\' timed out after ' + opts.timeout + 'ms');
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: null });
        reject(err);
        // reject and THEN kill to avoid race conditions with the handlers
        // above
        proc.kill(opts.killSignal);
      }, opts.timeout);
    }
  });
}

var SubProcess = (function (_EventEmitter) {
  function SubProcess(cmd) {
    var args = arguments[1] === undefined ? [] : arguments[1];

    _classCallCheck(this, SubProcess);

    _get(Object.getPrototypeOf(SubProcess.prototype), 'constructor', this).call(this);
    if (!cmd) throw new Error('Command is required');
    if (typeof cmd !== 'string') throw new Error('Command must be a string');
    if (!(args instanceof Array)) throw new Error('Args must be an array');
    this.cmd = cmd;
    this.args = args;
    this.proc = null;
  }

  _inherits(SubProcess, _EventEmitter);

  _createClass(SubProcess, [{
    key: 'start',
    value: function start() {
      var startDetector = arguments[0] === undefined ? null : arguments[0];
      var startDelay;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            startDelay = 10;

            // the default start detector is that we get any output
            if (startDetector === null) {
              startDetector = function (stdout, stderr) {
                return stdout || stderr;
              };
            }

            // if the user passes a number, then we simply delay a certain amount of
            // time before returning control
            if (typeof startDetector === 'number') {
              startDelay = startDetector;
              startDetector = null;
            }

            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              try {
                _this.proc = _child_process.spawn(_this.cmd, _this.args);
              } catch (e) {
                reject(e);
              }
              _this.proc.stdout.setEncoding('utf8');
              _this.proc.stderr.setEncoding('utf8');
              _this.lastLinePortion = { stdout: '', stderr: '' };

              var handleOutput = function handleOutput(data) {
                try {
                  if (startDetector && startDetector(data.stdout, data.stderr)) {
                    resolve();
                  }
                } catch (e) {
                  reject(e);
                }
                _this.emit('output', data.stdout, data.stderr);
                var _arr = ['stdout', 'stderr'];
                for (var _i = 0; _i < _arr.length; _i++) {
                  var stream = _arr[_i];
                  if (!data[stream]) continue;
                  var lines = data[stream].split('\n');
                  if (lines.length > 1) {
                    var retLines = lines.slice(0, -1);
                    retLines[0] = _this.lastLinePortion[stream] + retLines[0];
                    _this.lastLinePortion[stream] = lines[lines.length - 1];
                    _this.emit('lines-' + stream, retLines);
                  } else {
                    _this.lastLinePortion[stream] += lines[0];
                  }
                }
              };

              _this.proc.on('error', function (err) {
                _this.proc.removeAllListeners('exit');
                _this.proc.kill('SIGINT');
                reject(err);
              });

              _this.proc.stdout.pipe(_through2['default'](function (stdout) {
                handleOutput({ stdout: stdout, stderr: '' });
              }));

              _this.proc.stderr.pipe(_through2['default'](function (stderr) {
                handleOutput({ stdout: '', stderr: stderr });
              }));

              _this.proc.on('exit', function (code, signal) {
                _this.handleLastLines();
                _this.emit('exit', code, signal);
                _this.proc = null;
              });

              if (!startDetector) {
                setTimeout(function () {
                  resolve();
                }, startDelay);
              }
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'handleLastLines',
    value: function handleLastLines() {
      var _arr2 = ['stdout', 'stderr'];

      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
        var stream = _arr2[_i2];
        if (this.lastLinePortion[stream]) {
          this.emit('lines-' + stream, [this.lastLinePortion[stream]]);
          this.lastLinePortion[stream] = '';
        }
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var signal = arguments[0] === undefined ? 'SIGTERM' : arguments[0];
      var timeout = arguments[1] === undefined ? 10000 : arguments[1];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.proc) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Can\'t stop process; it\'s not currently running');

          case 2:
            this.handleLastLines();
            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              _this2.proc.on('close', resolve);
              _this2.proc.kill(signal);
              setTimeout(function () {
                reject(new Error('Process didn\'t end after ' + timeout + 'ms'));
              }, timeout);
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return SubProcess;
})(EventEmitter);

exports.exec = exec;
exports.spawn = _child_process.spawn;
exports.SubProcess = SubProcess;
//# sourceMappingURL=data:application/json;base64,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O0tBQ0Y7OztXQUVVO1VBQUMsTUFBTSxnQ0FBRyxTQUFTO1VBQUUsT0FBTyxnQ0FBRyxLQUFLOzs7Ozs7Z0JBQ3hDLElBQUksQ0FBQyxJQUFJOzs7OztrQkFDTixJQUFJLEtBQUssQ0FBQyxrREFBZ0QsQ0FBQzs7O0FBRW5FLGdCQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7Z0RBQ2hCLGFBQVksVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLO0FBQ3RDLHFCQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLHFCQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdkIsd0JBQVUsQ0FBQyxZQUFNO0FBQ2Ysc0JBQU0sQ0FBQyxJQUFJLEtBQUssZ0NBQTZCLE9BQU8sUUFBSyxDQUFDLENBQUM7ZUFDNUQsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUNiLENBQUM7Ozs7Ozs7S0FDSDs7O1NBOUdHLFVBQVU7R0FBUyxZQUFZOztRQWlINUIsSUFBSSxHQUFKLElBQUk7UUFBRSxLQUFLLGtCQWpNWCxLQUFLO1FBaU1RLFVBQVUsR0FBVixVQUFVIiwiZmlsZSI6ImxpYi90ZWVuX3Byb2Nlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcXVvdGUgfSBmcm9tICdzaGVsbC1xdW90ZSc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdGhyb3VnaCBmcm9tICd0aHJvdWdoJztcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSBldmVudHM7XG5cbmZ1bmN0aW9uIGV4ZWMgKGNtZCwgYXJncyA9IFtdLCBvcHRzID0ge30pIHtcbiAgLy8gZ2V0IGEgcXVvdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21tYW5kIGZvciBlcnJvciBzdHJpbmdzXG4gIGxldCByZXAgPSBxdW90ZShbY21kXS5jb25jYXQoYXJncykpO1xuXG4gIC8vIGV4dGVuZCBkZWZhdWx0IG9wdGlvbnM7IHdlJ3JlIGJhc2ljYWxseSByZS1pbXBsZW1lbnRpbmcgZXhlYydzIG9wdGlvbnNcbiAgLy8gZm9yIHVzZSBoZXJlIHdpdGggc3Bhd24gdW5kZXIgdGhlIGhvb2RcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBraWxsU2lnbmFsOiAnU0lHVEVSTScsXG4gICAgY3dkOiB1bmRlZmluZWQsXG4gICAgZW52OiBwcm9jZXNzLmVudixcbiAgICBpZ25vcmVPdXRwdXQ6IGZhbHNlXG4gIH0sIG9wdHMpO1xuXG4gIC8vIHRoaXMgaXMgYW4gYXN5bmMgZnVuY3Rpb24sIHNvIHJldHVybiBhIHByb21pc2VcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBzcGF3biB0aGUgY2hpbGQgcHJvY2VzcyB3aXRoIG9wdGlvbnM7IHdlIGRvbid0IGN1cnJlbnRseSBleHBvc2UgYW55IG9mXG4gICAgLy8gdGhlIG90aGVyICdzcGF3bicgb3B0aW9ucyB0aHJvdWdoIHRoZSBBUElcbiAgICBsZXQgcHJvYyA9IHNwYXduKGNtZCwgYXJncywge2N3ZDogb3B0cy5jd2QsIGVudjogb3B0cy5lbnZ9KTtcbiAgICBsZXQgc3Rkb3V0ID0gXCJcIiwgc3RkZXJyID0gXCJcIiwgdGltZXIgPSBudWxsO1xuXG4gICAgLy8gaWYgdGhlIHByb2Nlc3MgZXJyb3JzIG91dCwgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgcHJvYy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGBDb21tYW5kICcke3JlcH0nIGVycm9yZWQgb3V0OiAke2Vyci5zdGFja31gKSk7XG4gICAgfSk7XG5cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHN0ZG91dC9zdGRlcnIgaWYgd2UgaGF2ZW4ndCBzYWlkIG5vdCB0b1xuICAgIGlmICghb3B0cy5pZ25vcmVPdXRwdXQpIHtcbiAgICAgIHByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgc3Rkb3V0ICs9IGRhdGE7XG4gICAgICB9KTtcbiAgICAgIHByb2Muc3RkZXJyLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgc3RkZXJyICs9IGRhdGE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgcHJvY2VzcyBlbmRzLCBlaXRoZXIgcmVzb2x2ZSBvciByZWplY3QgdGhlIHByb21pc2UgYmFzZWQgb24gdGhlXG4gICAgLy8gZXhpdCBjb2RlIG9mIHRoZSBwcm9jZXNzLiBlaXRoZXIgd2F5LCBhdHRhY2ggc3Rkb3V0LCBzdGRlcnIsIGFuZCBjb2RlLlxuICAgIC8vIEFsc28gY2xlYW4gdXAgdGhlIHRpbWVyIGlmIGl0IGV4aXN0c1xuICAgIHByb2Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnRvU3RyaW5nKG9wdHMuZW5jb2RpbmcpO1xuICAgICAgc3RkZXJyID0gc3RkZXJyLnRvU3RyaW5nKG9wdHMuZW5jb2RpbmcpO1xuICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZSh7c3Rkb3V0LCBzdGRlcnIsIGNvZGV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYENvbW1hbmQgJyR7cmVwfScgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG4gICAgICAgIGVyciA9IE9iamVjdC5hc3NpZ24oZXJyLCB7c3Rkb3V0LCBzdGRlcnIsIGNvZGV9KTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB3ZSBzZXQgYSB0aW1lb3V0IG9uIHRoZSBjaGlsZCBwcm9jZXNzLCBjdXQgaW50byB0aGUgZXhlY3V0aW9uIGFuZFxuICAgIC8vIHJlamVjdCBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkLiBBdHRhY2ggdGhlIHN0ZG91dC9zdGRlcnIgd2UgY3VycmVudGx5XG4gICAgLy8gaGF2ZSBpbiBjYXNlIGl0J3MgaGVscGZ1bCBpbiBkZWJ1Z2dpbmdcbiAgICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzdGRvdXQgPSBzdGRvdXQudG9TdHJpbmcob3B0cy5lbmNvZGluZyk7XG4gICAgICAgIHN0ZGVyciA9IHN0ZGVyci50b1N0cmluZyhvcHRzLmVuY29kaW5nKTtcbiAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcihgQ29tbWFuZCAnJHtyZXB9JyB0aW1lZCBvdXQgYWZ0ZXIgJHtvcHRzLnRpbWVvdXR9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYG1zYCk7XG4gICAgICAgIGVyciA9IE9iamVjdC5hc3NpZ24oZXJyLCB7c3Rkb3V0LCBzdGRlcnIsIGNvZGU6IG51bGx9KTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIC8vIHJlamVjdCBhbmQgVEhFTiBraWxsIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aXRoIHRoZSBoYW5kbGVyc1xuICAgICAgICAvLyBhYm92ZVxuICAgICAgICBwcm9jLmtpbGwob3B0cy5raWxsU2lnbmFsKTtcbiAgICAgIH0sIG9wdHMudGltZW91dCk7XG4gICAgfVxuICB9KTtcbn1cblxuY2xhc3MgU3ViUHJvY2VzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChjbWQsIGFyZ3MgPSBbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFjbWQpIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKHR5cGVvZiBjbWQgIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpZiAoIShhcmdzIGluc3RhbmNlb2YgQXJyYXkpKSB0aHJvdyBuZXcgRXJyb3IoXCJBcmdzIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQgKHN0YXJ0RGV0ZWN0b3IgPSBudWxsKSB7XG4gICAgbGV0IHN0YXJ0RGVsYXkgPSAxMDtcblxuICAgIC8vIHRoZSBkZWZhdWx0IHN0YXJ0IGRldGVjdG9yIGlzIHRoYXQgd2UgZ2V0IGFueSBvdXRwdXRcbiAgICBpZiAoc3RhcnREZXRlY3RvciA9PT0gbnVsbCkge1xuICAgICAgc3RhcnREZXRlY3RvciA9IChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICByZXR1cm4gc3Rkb3V0IHx8IHN0ZGVycjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHVzZXIgcGFzc2VzIGEgbnVtYmVyLCB0aGVuIHdlIHNpbXBseSBkZWxheSBhIGNlcnRhaW4gYW1vdW50IG9mXG4gICAgLy8gdGltZSBiZWZvcmUgcmV0dXJuaW5nIGNvbnRyb2xcbiAgICBpZiAodHlwZW9mIHN0YXJ0RGV0ZWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGFydERlbGF5ID0gc3RhcnREZXRlY3RvcjtcbiAgICAgIHN0YXJ0RGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnByb2MgPSBzcGF3bih0aGlzLmNtZCwgdGhpcy5hcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9jLnN0ZG91dC5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgdGhpcy5wcm9jLnN0ZGVyci5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb24gPSB7c3Rkb3V0OiBcIlwiLCBzdGRlcnI6IFwiXCJ9O1xuXG4gICAgICBjb25zdCBoYW5kbGVPdXRwdXQgPSAoZGF0YSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdGFydERldGVjdG9yICYmIHN0YXJ0RGV0ZWN0b3IoZGF0YS5zdGRvdXQsIGRhdGEuc3RkZXJyKSkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ291dHB1dCcsIGRhdGEuc3Rkb3V0LCBkYXRhLnN0ZGVycik7XG4gICAgICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgICAgIGlmICghZGF0YVtzdHJlYW1dKSBjb250aW51ZTtcbiAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhW3N0cmVhbV0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXRMaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHJldExpbmVzWzBdID0gdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSArIHJldExpbmVzWzBdO1xuICAgICAgICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCByZXRMaW5lcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0gKz0gbGluZXNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnByb2Mub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgdGhpcy5wcm9jLnJlbW92ZUFsbExpc3RlbmVycygnZXhpdCcpO1xuICAgICAgICB0aGlzLnByb2Mua2lsbCgnU0lHSU5UJyk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJvYy5zdGRvdXQucGlwZSh0aHJvdWdoKHN0ZG91dCA9PiB7XG4gICAgICAgIGhhbmRsZU91dHB1dCh7c3Rkb3V0LCBzdGRlcnI6ICcnfSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHRoaXMucHJvYy5zdGRlcnIucGlwZSh0aHJvdWdoKHN0ZGVyciA9PiB7XG4gICAgICAgIGhhbmRsZU91dHB1dCh7c3Rkb3V0OiAnJywgc3RkZXJyfSk7XG4gICAgICB9KSk7XG5cbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVMYXN0TGluZXMoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdleGl0JywgY29kZSwgc2lnbmFsKTtcbiAgICAgICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXN0YXJ0RGV0ZWN0b3IpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBzdGFydERlbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUxhc3RMaW5lcyAoKSB7XG4gICAgZm9yIChsZXQgc3RyZWFtIG9mIFsnc3Rkb3V0JywgJ3N0ZGVyciddKSB7XG4gICAgICBpZiAodGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSkge1xuICAgICAgICB0aGlzLmVtaXQoYGxpbmVzLSR7c3RyZWFtfWAsIFt0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dXSk7XG4gICAgICAgIHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzdG9wIChzaWduYWwgPSAnU0lHVEVSTScsIHRpbWVvdXQgPSAxMDAwMCkge1xuICAgIGlmICghdGhpcy5wcm9jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdG9wIHByb2Nlc3M7IGl0J3Mgbm90IGN1cnJlbnRseSBydW5uaW5nXCIpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZUxhc3RMaW5lcygpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByb2Mub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgICB0aGlzLnByb2Mua2lsbChzaWduYWwpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFByb2Nlc3MgZGlkbid0IGVuZCBhZnRlciAke3RpbWVvdXR9bXNgKSk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBleGVjLCBzcGF3biwgU3ViUHJvY2VzcyB9O1xuIl19